{"language":"Solidity","sources":{"nearx.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\ncontract NearDeFiSystem is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 public usdtToken = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n    IERC20 public nearToken = IERC20(0x1Fa4a73a3F0133f0025378af00236f3aBDEE5D63);\r\n    uint256 public constant USDT_TO_NEAR_RATE = 25;\r\n    uint256 public constant RATE_PRECISION = 10;\r\n\r\n    struct User {\r\n        address referrer;\r\n        address rootReferrer;\r\n        uint256 totalDeposit;\r\n        uint256 staticRewardReleased;\r\n        uint256 dynamicRewardReleased;\r\n        uint256 withdrawnAmount;\r\n        uint256 lastUpdateTime;\r\n        uint256 pendingStaticReward;\r\n        uint256 pendingDynamicReward;\r\n        uint256 level;\r\n        mapping(uint256 => uint256) referralsCount;\r\n        uint256 usdtBalance;\r\n        uint256 lastWithdrawTime;\r\n    }\r\n\r\n    uint256 public totalDeposited;\r\n    mapping(address => User) public users;\r\n    mapping(address => mapping(uint256 => address[])) public referrals;\r\n    mapping(address => bool) public restrictedUsers;\r\n    uint256 public totalStaticRewards;\r\n    uint256 public constant DAY_IN_SECONDS = 86400;\r\n    mapping(address => bool) public withdrawBlacklist;\r\n\r\n    uint256[5] public levelRequirements = [\r\n        5000 ether,\r\n        20000 ether,\r\n        100000 ether,\r\n        500000 ether,\r\n        2000000 ether\r\n    ];\r\n\r\n    event Deposited(address indexed user, uint256 amount, uint256 totalDeposited);\r\n    event ReferrerBound(address indexed user, address referrer);\r\n    event WithdrawRequested(address indexed user, uint256 amount);\r\n    event RewardReleased(address indexed user, uint256 staticReward, uint256 dynamicReward);\r\n    event USDTWithdrawn(address indexed privilegedAddress, uint256 amount);\r\n    event UserRestricted(address indexed user, bool restricted);\r\n    event RewardsUpdated(address indexed user, uint256 staticReward, uint256 dynamicReward);\r\n    event LevelUpgraded(address indexed user, uint256 newLevel);\r\n    event WithdrawAttempt(address indexed user, uint256 staticReward, uint256 dynamicReward);\r\n    event WithdrawBlacklistUpdated(address indexed user, bool isBlacklisted);\r\n\r\n    constructor(\r\n        address initialOwner\r\n    ) Ownable(initialOwner) {\r\n        totalDeposited = 0;\r\n        users[initialOwner].rootReferrer = initialOwner;\r\n    }\r\n\r\n    function getLevel(address user) public view returns (uint256) {\r\n        address root = _findRootReferrer(user);\r\n        return root == address(0) ? 0 : users[root].level;\r\n    }\r\n\r\n    function _findRootReferrer(address user) internal view returns (address) {\r\n        address current = user;\r\n        while (users[current].referrer != address(0)) {\r\n            current = users[current].referrer;\r\n        }\r\n        return current;\r\n    }\r\n\r\n    function upgradeRootLevel(address user, uint256 newLevel) external onlyOwner {\r\n        require(newLevel <= 5, \"Max level is 5\");\r\n        require(users[user].referrer == address(0) || users[user].rootReferrer == user, \"Must be root user\");\r\n        users[user].level = newLevel;\r\n        emit LevelUpgraded(user, newLevel);\r\n    }\r\n\r\n    function upgradeLevel() external {\r\n        User storage u = users[msg.sender];\r\n        address root = _findRootReferrer(msg.sender);\r\n        require(root == msg.sender, \"Only root user can upgrade\");\r\n        uint256 currentLevel = u.level;\r\n        require(currentLevel < 5, \"Already at max level\");\r\n\r\n        uint256 teamPerformance = getAllReferralsTotalPerformance(root);\r\n        require(teamPerformance >= levelRequirements[currentLevel], \"Insufficient team performance\");\r\n\r\n        u.level = currentLevel.add(1);\r\n        emit LevelUpgraded(msg.sender, u.level);\r\n    }\r\n\r\n    function getPendingReward(address user) public view returns (uint256) {\r\n        User storage u = users[user];\r\n        if (u.totalDeposit == 0) return 0;\r\n\r\n        uint256 daysPassed = (block.timestamp - u.lastUpdateTime) / DAY_IN_SECONDS;\r\n        uint256 staticReward = u.pendingStaticReward;\r\n        uint256 dynamicReward = u.pendingDynamicReward;\r\n\r\n        if (daysPassed > 0) {\r\n            uint256 dailyStaticReward = getTodayStaticReward(user);\r\n            uint256 additionalStatic = dailyStaticReward.mul(daysPassed);\r\n            uint256 stageMultiplier = _getStageMultiplier(u.totalDeposit);\r\n            uint256 maxReward = u.totalDeposit.mul(stageMultiplier).div(10);\r\n            uint256 totalStatic = u.staticRewardReleased.add(staticReward).add(additionalStatic);\r\n            if (totalStatic > maxReward) {\r\n                additionalStatic = maxReward.sub(u.staticRewardReleased).sub(staticReward);\r\n            }\r\n            staticReward = staticReward.add(additionalStatic);\r\n\r\n            dynamicReward = dynamicReward.add(calculateDynamicReward(user).mul(daysPassed));\r\n        }\r\n        return staticReward.add(dynamicReward);\r\n    }\r\n\r\n    function _updateRewards(address user) internal {\r\n        User storage u = users[user];\r\n        if (u.totalDeposit == 0) return;\r\n\r\n        uint256 pendingReward = getPendingReward(user);\r\n        uint256 staticReward = pendingReward.sub(u.pendingDynamicReward);\r\n        uint256 dynamicReward = pendingReward.sub(u.pendingStaticReward);\r\n\r\n        u.pendingStaticReward = 0;\r\n        u.pendingDynamicReward = 0;\r\n        u.staticRewardReleased = u.staticRewardReleased.add(staticReward);\r\n        u.dynamicRewardReleased = u.dynamicRewardReleased.add(dynamicReward);\r\n        u.usdtBalance = u.usdtBalance.add(staticReward).add(dynamicReward);\r\n        u.lastUpdateTime = block.timestamp;\r\n\r\n        totalStaticRewards = totalStaticRewards.add(staticReward);\r\n\r\n        emit RewardsUpdated(user, staticReward, dynamicReward);\r\n    }\r\n\r\n    function deposit(uint256 amount) external {\r\n        require(amount >= 100 ether, \"Minimum deposit is 100 USDT\");\r\n        require(usdtToken.transferFrom(msg.sender, address(this), amount), \"USDT transfer failed\");\r\n\r\n        _updateRewards(msg.sender);\r\n        User storage u = users[msg.sender];\r\n        if (u.totalDeposit == 0) {\r\n            u.lastUpdateTime = block.timestamp;\r\n            if (u.referrer == address(0)) u.rootReferrer = msg.sender;\r\n        }\r\n        u.totalDeposit = u.totalDeposit.add(amount);\r\n        totalDeposited = totalDeposited.add(amount);\r\n\r\n        uint256 stageMultiplier = _getStageMultiplier(amount);\r\n        u.usdtBalance = u.usdtBalance.add(amount.mul(stageMultiplier).div(10));\r\n\r\n        emit Deposited(msg.sender, amount, totalDeposited);\r\n    }\r\n\r\n    function bindReferrer(address referrer) external {\r\n        User storage u = users[msg.sender];\r\n        require(u.referrer == address(0), \"Referrer already set\");\r\n        require(referrer != msg.sender, \"Cannot refer yourself\");\r\n        require(referrer != address(0), \"Invalid referrer address\");\r\n\r\n        uint256 chainDepth = getReferralChainDepth(referrer);\r\n        require(chainDepth < 10, \"Referral chain too deep\");\r\n\r\n        _updateRewards(msg.sender);\r\n        u.referrer = referrer;\r\n        u.rootReferrer = _findRootReferrer(referrer);\r\n        _updateReferralStructure(msg.sender, referrer);\r\n        emit ReferrerBound(msg.sender, referrer);\r\n    }\r\n\r\n    function _updateReferralStructure(address user, address referrer) internal {\r\n        referrals[referrer][1].push(user);\r\n        users[referrer].referralsCount[1] = users[referrer].referralsCount[1].add(1);\r\n    }\r\n\r\n    function getReferralChainDepth(address user) internal view returns (uint256) {\r\n        uint256 depth = 0;\r\n        address current = user;\r\n        while (current != address(0) && depth < 10) {\r\n            current = users[current].referrer;\r\n            depth = depth.add(1);\r\n        }\r\n        return depth;\r\n    }\r\n\r\n    function releaseRewards() external {\r\n        _updateRewards(msg.sender);\r\n        User storage u = users[msg.sender];\r\n        require(u.usdtBalance > 0, \"No rewards to release\");\r\n        uint256 staticReward = u.staticRewardReleased;\r\n        uint256 dynamicReward = u.dynamicRewardReleased;\r\n        u.pendingStaticReward = 0;\r\n        u.pendingDynamicReward = 0;\r\n        emit RewardReleased(msg.sender, staticReward, dynamicReward);\r\n    }\r\n\r\n    function withdraw(uint256 amount) external {\r\n        User storage u = users[msg.sender];\r\n        _updateRewards(msg.sender);\r\n        require(!restrictedUsers[msg.sender], \"User is restricted\");\r\n        require(u.totalDeposit > 0, \"No deposit\");\r\n        require(block.timestamp >= u.lastWithdrawTime + DAY_IN_SECONDS, \"Can only withdraw once every 24 hours\");\r\n        require(amount <= u.usdtBalance, \"Insufficient usdtBalance\");\r\n        require(!withdrawBlacklist[msg.sender], \"You have been blacklisted from withdrawing\");\r\n\r\n        // 计算对应的NEAR数量 (2.5 USDT = 1 NEAR)\r\n        uint256 nearAmount = amount.mul(RATE_PRECISION).div(USDT_TO_NEAR_RATE);\r\n        \r\n        u.withdrawnAmount = u.withdrawnAmount.add(amount);\r\n        u.usdtBalance = u.usdtBalance.sub(amount);\r\n        u.lastWithdrawTime = block.timestamp;\r\n\r\n        // 直接转移NEAR代币给用户，无手续费\r\n        require(nearToken.transfer(msg.sender, nearAmount), \"NEAR transfer failed\");\r\n\r\n        emit WithdrawRequested(msg.sender, nearAmount);\r\n        emit WithdrawAttempt(msg.sender, getTodayStaticReward(msg.sender), calculateDynamicReward(msg.sender));\r\n    }\r\n\r\n    function setWithdrawBlacklist(address user, bool isBlacklisted) external onlyOwner {\r\n        withdrawBlacklist[user] = isBlacklisted;\r\n        emit WithdrawBlacklistUpdated(user, isBlacklisted);\r\n    }\r\n\r\n    function isBlacklisted(address user) external view returns (bool) {\r\n        return withdrawBlacklist[user];\r\n    }\r\n\r\n    function getNearBalance() external view returns (uint256) {\r\n        return nearToken.balanceOf(address(this));\r\n    }\r\n\r\n    function withdrawNear(uint256 amount) external onlyOwner {\r\n        require(nearToken.transfer(msg.sender, amount), \"NEAR transfer failed\");\r\n    }\r\n\r\n    function _getTotalDailyReward(address user) internal view returns (uint256) {\r\n        return getTodayStaticReward(user).add(calculateDynamicReward(user));\r\n    }\r\n\r\n    function hasWithdrawnInLast24Hours(address user) public view returns (bool) {\r\n        return block.timestamp < users[user].lastWithdrawTime + DAY_IN_SECONDS;\r\n    }\r\n\r\n    function getLastWithdrawTime(address user) public view returns (uint256) {\r\n        return users[user].lastWithdrawTime;\r\n    }\r\n\r\n    function getReleasedReward(address user) public view returns (uint256) {\r\n        return users[user].staticRewardReleased.add(users[user].dynamicRewardReleased);\r\n    }\r\n\r\n    function getTodayStaticReward(address user) public view returns (uint256) {\r\n        if (users[user].totalDeposit == 0) return 0;\r\n        return users[user].totalDeposit.mul(_getDailyRate(users[user].totalDeposit)).div(1000);\r\n    }\r\n\r\n    function getTodayDynamicReward(address user) public view returns (uint256) {\r\n        return calculateDynamicReward(user);\r\n    }\r\n\r\n    function getStakeReward(address user) public view returns (uint256) {\r\n        return users[user].staticRewardReleased;\r\n    }\r\n\r\n    function getDirectReward(address user) public view returns (uint256) {\r\n        return _calculateDirectReward(user);\r\n    }\r\n\r\n    function getShareReward(address user) public view returns (uint256) {\r\n        return _calculateShareReward(user);\r\n    }\r\n\r\n    function getTeamReward(address user) public view returns (uint256) {\r\n        return _calculateTeamReward(user);\r\n    }\r\n\r\n    function getGlobalDividend(address user) public view returns (uint256) {\r\n        return _calculateGlobalDividend(user);\r\n    }\r\n\r\n    function getTotalReleasable(address user) public view returns (uint256) {\r\n        return getReleasedReward(user).add(getPendingReward(user));\r\n    }\r\n\r\n    function getWithdrawn(address user) public view returns (uint256) {\r\n        return users[user].withdrawnAmount;\r\n    }\r\n\r\n    function getWithdrawableAmount(address user) public view returns (uint256) {\r\n        return getTotalReleasable(user).sub(users[user].withdrawnAmount);\r\n    }\r\n\r\n    function getUsdtBalance(address user) public view returns (uint256) {\r\n        return users[user].usdtBalance;\r\n    }\r\n\r\n    function getPendingStaticReward(address user) public view returns (uint256) {\r\n        User storage u = users[user];\r\n        uint256 currentDayStart = block.timestamp - (block.timestamp % DAY_IN_SECONDS);\r\n        uint256 lastUpdateDayStart = u.lastUpdateTime - (u.lastUpdateTime % DAY_IN_SECONDS);\r\n        uint256 staticReward = u.pendingStaticReward;\r\n\r\n        if (currentDayStart > lastUpdateDayStart && u.totalDeposit > 0) {\r\n            uint256 daysPassed = (currentDayStart - lastUpdateDayStart) / DAY_IN_SECONDS;\r\n            uint256 dailyStaticReward = getTodayStaticReward(user);\r\n            uint256 additionalStatic = dailyStaticReward.mul(daysPassed);\r\n            uint256 stageMultiplier = _getStageMultiplier(u.totalDeposit);\r\n            uint256 maxReward = u.totalDeposit.mul(stageMultiplier).div(10);\r\n            uint256 totalStatic = u.staticRewardReleased.add(staticReward).add(additionalStatic);\r\n            if (totalStatic > maxReward) {\r\n                additionalStatic = maxReward.sub(u.staticRewardReleased).sub(staticReward);\r\n            }\r\n            staticReward = staticReward.add(additionalStatic);\r\n        }\r\n        return staticReward;\r\n    }\r\n\r\n    function _getStageMultiplier(uint256 amount) private pure returns (uint256) {\r\n        if (amount >= 100 ether && amount <= 500 ether) return 15;\r\n        if (amount >= 501 ether && amount <= 1000 ether) return 20;\r\n        if (amount >= 1001 ether && amount <= 3000 ether) return 25;\r\n        if (amount >= 3001 ether) return 30;\r\n        return 0;\r\n    }\r\n\r\n    function _getDailyRate(uint256 amount) private pure returns (uint256) {\r\n        if (amount <= 500 ether) return 7;\r\n        if (amount <= 1000 ether) return 8;\r\n        if (amount <= 3000 ether) return 9;\r\n        return 10;\r\n    }\r\n\r\n    function calculateDynamicReward(address user) internal view returns (uint256) {\r\n        return _calculateDirectReward(user)\r\n            .add(_calculateShareReward(user))\r\n            .add(_calculateTeamReward(user))\r\n            .add(_calculateGlobalDividend(user));\r\n    }\r\n\r\n    function getPendingDynamicReward(address user) public view returns (uint256) {\r\n        User storage u = users[user];\r\n        uint256 currentDayStart = block.timestamp - (block.timestamp % DAY_IN_SECONDS);\r\n        uint256 lastUpdateDayStart = u.lastUpdateTime - (u.lastUpdateTime % DAY_IN_SECONDS);\r\n        uint256 dynamicReward = u.pendingDynamicReward;\r\n\r\n        if (currentDayStart > lastUpdateDayStart && u.totalDeposit > 0) {\r\n            uint256 daysPassed = (currentDayStart - lastUpdateDayStart) / DAY_IN_SECONDS;\r\n            dynamicReward = dynamicReward.add(calculateDynamicReward(user).mul(daysPassed));\r\n        }\r\n        return dynamicReward;\r\n    }\r\n\r\n    function _calculateDirectReward(address user) internal view returns (uint256) {\r\n        uint256 reward = 0;\r\n        bool noBurn = users[user].totalDeposit >= 3001 ether;\r\n        \r\n        for (uint256 i = 1; i <= 6; i++) {\r\n            address[] memory refs = getReferralsAtLevel(user, i);\r\n            for (uint256 j = 0; j < refs.length; j++) {\r\n                uint256 refDeposit = users[refs[j]].totalDeposit;\r\n                uint256 rate = (i == 1) ? 50 : (i == 2) ? 30 : 10;\r\n                uint256 burnAmount = noBurn ? refDeposit : \r\n                    (refDeposit > users[user].totalDeposit ? users[user].totalDeposit : refDeposit);\r\n                reward = reward.add(burnAmount.mul(rate).div(1000));\r\n            }\r\n        }\r\n        return reward.div(100);\r\n    }\r\n\r\n    function _calculateShareReward(address user) internal view returns (uint256) {\r\n        uint256 reward = 0;\r\n        uint256 maxLevel = users[user].referralsCount[1] > 10 ? 10 : users[user].referralsCount[1];\r\n        bool noBurn = users[user].totalDeposit >= 3001 ether;\r\n        \r\n        for (uint256 i = 1; i <= maxLevel; i++) {\r\n            address[] memory refs = getReferralsAtLevel(user, i);\r\n            for (uint256 j = 0; j < refs.length; j++) {\r\n                uint256 staticReward = getTodayStaticReward(refs[j]);\r\n                uint256 refDeposit = users[refs[j]].totalDeposit;\r\n                uint256 burnAmount = noBurn ? staticReward : \r\n                    (refDeposit > users[user].totalDeposit ? getTodayStaticReward(user) : staticReward);\r\n                reward = reward.add(burnAmount.mul(5).div(100));\r\n            }\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    function getReferralsAtLevel(address user, uint256 level) internal view returns (address[] memory) {\r\n        if (level == 1) return referrals[user][1];\r\n        \r\n        address[] memory directRefs = referrals[user][1];\r\n        address[] memory result = new address[](0);\r\n        for (uint256 i = 0; i < directRefs.length; i++) {\r\n            address[] memory subRefs = getReferralsAtLevel(directRefs[i], level.sub(1));\r\n            result = concatArrays(result, subRefs);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function concatArrays(address[] memory arr1, address[] memory arr2) internal pure returns (address[] memory) {\r\n        address[] memory result = new address[](arr1.length + arr2.length);\r\n        for (uint256 i = 0; i < arr1.length; i++) {\r\n            result[i] = arr1[i];\r\n        }\r\n        for (uint256 i = 0; i < arr2.length; i++) {\r\n            result[arr1.length + i] = arr2[i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _calculateTeamReward(address user) internal view returns (uint256) {\r\n        address root = _findRootReferrer(user);\r\n        uint256 teamPerformance = root == address(0) ? 0 : getAllReferralsTotalPerformance(root);\r\n        uint256 rate = _getTeamRate(teamPerformance);\r\n        if (rate == 0) return 0;\r\n\r\n        return getTodayStaticReward(user).mul(rate).div(100); // 修正为按比例计算\r\n        \r\n    }\r\n\r\n    function _getTeamRate(uint256 teamPerformance) private pure returns (uint256) {\r\n        if (teamPerformance >= 2000000 ether) return 25;\r\n        if (teamPerformance >= 500000 ether) return 20;\r\n        if (teamPerformance >= 100000 ether) return 15;\r\n        if (teamPerformance >= 20000 ether) return 10;\r\n        if (teamPerformance >= 5000 ether) return 5;\r\n        return 0;\r\n    }\r\n\r\n    function _calculateGlobalDividend(address user) internal view returns (uint256) {\r\n        address root = _findRootReferrer(user);\r\n        uint256 teamPerformance = root == address(0) ? 0 : getAllReferralsTotalPerformance(root);\r\n        if (teamPerformance >= 5000000 ether) {\r\n            return totalStaticRewards.mul(5).div(100).div(365);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getTotalDeposited() external view returns (uint256) {\r\n        return totalDeposited;\r\n    }\r\n\r\n    function withdrawUSDT(uint256 amount) external onlyOwner {\r\n        uint256 balance = usdtToken.balanceOf(address(this));\r\n        require(amount <= balance, \"Insufficient USDT balance\");\r\n        require(usdtToken.transfer(owner(), amount), \"USDT transfer failed\");\r\n        emit USDTWithdrawn(owner(), amount);\r\n    }\r\n\r\n    function getReferrals(address user, uint256 level) external view returns (address[] memory) {\r\n        return getReferralsAtLevel(user, level);\r\n    }\r\n\r\n    function restrictUser(address user, bool restrict) external onlyOwner {\r\n        _updateRewards(user);\r\n        restrictedUsers[user] = restrict;\r\n        emit UserRestricted(user, restrict);\r\n    }\r\n\r\n    function getDirectReferralsTotalPerformance(address user) public view returns (uint256) {\r\n        uint256 totalPerformance = 0;\r\n        address[] memory directRefs = referrals[user][1];\r\n        for (uint256 i = 0; i < directRefs.length; i++) {\r\n            totalPerformance = totalPerformance.add(users[directRefs[i]].totalDeposit);\r\n        }\r\n        return totalPerformance;\r\n    }\r\n\r\n    function getAllReferralsTotalPerformance(address user) public view returns (uint256) {\r\n        address root = _findRootReferrer(user);\r\n        uint256 totalPerformance = 0;\r\n        address[] memory allRefs = getAllReferrals(root);\r\n        for (uint256 i = 0; i < allRefs.length; i++) {\r\n            totalPerformance = totalPerformance.add(users[allRefs[i]].totalDeposit);\r\n        }\r\n        return totalPerformance;\r\n    }\r\n\r\n    function getAllReferrals(address user) internal view returns (address[] memory) {\r\n        address[] memory result = new address[](0);\r\n        for (uint256 i = 1; i <= 10; i++) {\r\n            address[] memory refs = getReferralsAtLevel(user, i);\r\n            result = concatArrays(result, refs);\r\n            if (refs.length == 0) break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getDirectReferralsWithDepositCount(address user) public view returns (uint256) {\r\n        uint256 count = 0;\r\n        address[] memory directRefs = referrals[user][1];\r\n        for (uint256 i = 0; i < directRefs.length; i++) {\r\n            if (users[directRefs[i]].totalDeposit > 0) {\r\n                count = count.add(1);\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function getPerformanceByLevel(address user) public view returns (uint256[10] memory) {\r\n        uint256[10] memory performanceByLevel;\r\n        for (uint256 level = 1; level <= 10; level++) {\r\n            uint256 totalPerformance = 0;\r\n            address[] memory refs = getReferralsAtLevel(user, level);\r\n            for (uint256 i = 0; i < refs.length; i++) {\r\n                totalPerformance = totalPerformance.add(users[refs[i]].totalDeposit);\r\n            }\r\n            performanceByLevel[level - 1] = totalPerformance;\r\n        }\r\n        return performanceByLevel;\r\n    }\r\n\r\n    function batchUpdateRewards(address[] calldata userAddresses) external onlyOwner {\r\n        for (uint256 i = 0; i < userAddresses.length; i++) {\r\n            _updateRewards(userAddresses[i]);\r\n        }\r\n    }\r\n}"},"@openzeppelin/contracts/utils/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}